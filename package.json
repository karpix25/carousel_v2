// package.json
{
  "name": "professional-card-api",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  },
  "dependencies": {
    "hono": "^4.0.0",
    "@hono/node-server": "^1.8.0",
    "satori": "^0.10.0",
    "sharp": "^0.33.0",
    "marked": "^12.0.0",
    "colorjs.io": "^0.5.0",
    "css-line-break": "^2.1.0",
    "react": "^18.2.0",
    "@types/react": "^18.2.0"
  },
  "devDependencies": {
    "typescript": "^5.3.0",
    "tsx": "^4.7.0",
    "@types/node": "^20.11.0"
  }
}

// src/types/index.ts
export interface CardConfig {
  content: string; // Markdown content
  style: 'instagram' | 'modern' | 'classic';
  username?: string; // Для Instagram стиля
  authorName?: string; // Имя автора
  slideNumber?: string; // Номер слайда (1/10)
  colorTheme: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
  };
  typography: {
    headingFont: string;
    bodyFont: string;
    fontSize: number;
    lineHeight: number;
  };
  dimensions: {
    width: number;
    height: number;
  };
  features: {
    hangingPunctuation: boolean;
    widowOrphanControl: boolean;
    coloredText: boolean;
    svgPattern: string | null;
  };
}

export interface ParsedContent {
  title?: string;
  subtitle?: string;
  body: string;
  highlights: string[];
}

export interface TypographySettings {
  fontSize: number;
  lineHeight: number;
  letterSpacing: number;
  wordSpacing: number;
  textAlign: 'left' | 'center' | 'right' | 'justify';
}

// src/services/markdown-parser.ts
import { marked } from 'marked';
import type { ParsedContent } from '../types/index.js';

export class MarkdownParser {
  private static extractTitle(content: string): string | undefined {
    const titleMatch = content.match(/^#\s+(.+)$/m);
    return titleMatch?.[1];
  }

  private static extractSubtitle(content: string): string | undefined {
    const subtitleMatch = content.match(/^##\s+(.+)$/m);
    return subtitleMatch?.[1];
  }

  private static extractHighlights(content: string): string[] {
    const highlights: string[] = [];
    const coloredTextRegex = /\*\*\*(.*?)\*\*\*/g;
    let match;
    
    while ((match = coloredTextRegex.exec(content)) !== null) {
      highlights.push(match[1]);
    }
    
    return highlights;
  }

  static parse(markdown: string): ParsedContent {
    const title = this.extractTitle(markdown);
    const subtitle = this.extractSubtitle(markdown);
    const highlights = this.extractHighlights(markdown);
    
    // Remove titles and convert to HTML
    let processedMarkdown = markdown
      .replace(/^#\s+.+$/m, '')
      .replace(/^##\s+.+$/m, '')
      .replace(/\*\*\*(.*?)\*\*\*/g, '<span class="highlight">$1</span>')
      .trim();
    
    const body = marked(processedMarkdown);
    
    return {
      title,
      subtitle,
      body,
      highlights
    };
  }
}

// src/services/typography.ts
import { Color } from 'colorjs.io';
import { LineBreaker } from 'css-line-break';
import type { TypographySettings } from '../types/index.js';

export class TypographyService {
  private static hangingPunctuationChars = ['.', ',', ';', ':', '!', '?', '"', "'", '»', '›'];
  
  static calculateOptimalLineHeight(fontSize: number): number {
    // Golden ratio based line height
    return fontSize * 1.618;
  }
  
  static applyHangingPunctuation(text: string): string {
    return text.replace(
      new RegExp(`([${this.hangingPunctuationChars.join('')}])`, 'g'),
      '<span style="margin-left: -0.3em; text-indent: 0.3em; display: inline-block;">$1</span>'
    );
  }
  
  static controlWidowsOrphans(text: string): string {
    // Replace space before last word with non-breaking space
    return text.replace(/\s+(\S+\s*)$/, '\u00A0$1');
  }
  
  static optimizeLineBreaks(text: string, maxWidth: number): string {
    const breaker = new LineBreaker(text);
    let result = '';
    let currentLine = '';
    
    for (const word of breaker) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word;
      
      if (this.measureTextWidth(testLine) > maxWidth && currentLine) {
        result += this.controlWidowsOrphans(currentLine) + '\n';
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    
    if (currentLine) {
      result += this.controlWidowsOrphans(currentLine);
    }
    
    return result;
  }
  
  private static measureTextWidth(text: string): number {
    // Simplified width calculation - in real implementation use actual font metrics
    return text.length * 0.6;
  }
  
  static generateColorVariations(baseColor: string, count: number = 5): string[] {
    const color = new Color(baseColor);
    const variations: string[] = [];
    
    for (let i = 0; i < count; i++) {
      const lightness = 0.2 + (i / count) * 0.6;
      const variation = color.set('oklch.l', lightness);
      variations.push(variation.toString({ format: 'hex' }));
    }
    
    return variations;
  }
  
  static ensureContrast(foreground: string, background: string, minRatio: number = 4.5): string {
    const fg = new Color(foreground);
    const bg = new Color(background);
    
    const contrast = Math.abs(fg.contrast(bg, 'WCAG21'));
    
    if (contrast >= minRatio) {
      return foreground;
    }
    
    // Adjust lightness to meet contrast requirements
    const targetLightness = bg.get('oklch.l') > 0.5 ? 0.1 : 0.9;
    return fg.set('oklch.l', targetLightness).toString({ format: 'hex' });
  }
}

// src/services/patterns.ts
export class PatternService {
  static generateSVGPattern(type: string, color: string): string {
    const patterns = {
      dots: `
        <pattern id="dots" patternUnits="userSpaceOnUse" width="20" height="20">
          <circle cx="10" cy="10" r="2" fill="${color}" opacity="0.1"/>
        </pattern>
      `,
      lines: `
        <pattern id="lines" patternUnits="userSpaceOnUse" width="20" height="20">
          <path d="M0,10 L20,10" stroke="${color}" stroke-width="1" opacity="0.1"/>
        </pattern>
      `,
      grid: `
        <pattern id="grid" patternUnits="userSpaceOnUse" width="20" height="20">
          <path d="M20,0 L0,0 L0,20" fill="none" stroke="${color}" stroke-width="1" opacity="0.05"/>
        </pattern>
      `,
      diagonal: `
        <pattern id="diagonal" patternUnits="userSpaceOnUse" width="20" height="20">
          <path d="M0,20 L20,0" stroke="${color}" stroke-width="1" opacity="0.1"/>
        </pattern>
      `
    };
    
    return patterns[type as keyof typeof patterns] || patterns.dots;
  }
}

// src/components/CardComponent.tsx
import type { CardConfig, ParsedContent } from '../types/index.js';

interface CardProps {
  config: CardConfig;
  content: ParsedContent;
}

// Карточка в стиле Instagram Stories/Posts (основанная на ваших примерах)
export function InstagramCard({ config, content }: CardProps) {
  const { colorTheme, typography, dimensions, features } = config;
  
  return (
    <div
      style={{
        width: dimensions.width,
        height: dimensions.height,
        background: colorTheme.background,
        padding: '48px 40px 40px 40px', // Отступы как в примерах
        display: 'flex',
        flexDirection: 'column',
        fontFamily: typography.bodyFont,
        color: colorTheme.text,
        position: 'relative',
        borderRadius: '24px',
        overflow: 'hidden'
      }}
    >
      {/* Header с username и номером слайда */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '60px',
          fontSize: '16px',
          fontWeight: 400,
          opacity: 0.7
        }}
      >
        <span>@{config.username || 'username'}</span>
        <span>{config.slideNumber || '1/10'}</span>
      </div>
      
      {/* Основной заголовок */}
      {content.title && (
        <h1
          style={{
            fontFamily: typography.headingFont,
            fontSize: '48px', // Крупный заголовок как в примерах
            lineHeight: 1.1,
            fontWeight: 700,
            marginBottom: '40px',
            letterSpacing: '-0.02em'
          }}
        >
          {/* Поддержка выделенного текста */}
          {content.title.split(' ').map((word, index) => {
            if (content.highlights.includes(word)) {
              return (
                <span key={index} style={{ textDecoration: 'underline', textDecorationColor: colorTheme.accent }}>
                  {word}{' '}
                </span>
              );
            }
            return word + ' ';
          })}
        </h1>
      )}
      
      {/* Основной текст */}
      <div
        style={{
          flex: 1,
          fontSize: '20px',
          lineHeight: 1.4,
          marginBottom: '40px'
        }}
        dangerouslySetInnerHTML={{ __html: content.body }}
      />
      
      {/* Footer с именем/подписью */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          fontSize: '16px',
          opacity: 0.6
        }}
      >
        <span>{config.authorName || 'Твоё имя или подпись'}</span>
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <line x1="5" y1="12" x2="19" y2="12"></line>
          <polyline points="12,5 19,12 12,19"></polyline>
        </svg>
      </div>
      
      {/* Декоративные кривые как в примерах */}
      {features.svgPattern && (
        <svg
          style={{
            position: 'absolute',
            top: 0,
            right: 0,
            width: '300px',
            height: '400px',
            opacity: 0.1,
            pointerEvents: 'none'
          }}
          viewBox="0 0 300 400"
        >
          <path
            d="M300,0 C200,100 250,200 150,300 C100,350 200,400 300,400 Z"
            fill={colorTheme.accent}
          />
        </svg>
      )}
    </div>
  );
}

export function ModernCard({ config, content }: CardProps) {
  const { colorTheme, typography, dimensions, features } = config;
  
  return (
    <div
      style={{
        width: dimensions.width,
        height: dimensions.height,
        background: colorTheme.background,
        padding: '64px 48px', // Более сбалансированные отступы
        display: 'flex',
        flexDirection: 'column',
        fontFamily: typography.bodyFont,
        fontSize: typography.fontSize,
        lineHeight: typography.lineHeight,
        color: colorTheme.text,
        position: 'relative',
        borderRadius: '16px',
        overflow: 'hidden'
      }}
    >
      {/* Минималистичный заголовок */}
      {content.title && (
        <h1
          style={{
            fontFamily: typography.headingFont,
            fontSize: '36px',
            lineHeight: 1.2,
            color: colorTheme.primary,
            marginBottom: '32px',
            fontWeight: 600,
            letterSpacing: '-0.025em'
          }}
        >
          {content.title}
        </h1>
      )}
      
      {/* Основной контент */}
      <div
        style={{
          flex: 1,
          fontSize: '18px',
          lineHeight: 1.6,
          color: colorTheme.text
        }}
        dangerouslySetInnerHTML={{ __html: content.body }}
      />
      
      {/* Минималистичный акцент */}
      <div
        style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          height: '4px',
          background: `linear-gradient(90deg, ${colorTheme.primary}, ${colorTheme.accent})`
        }}
      />
    </div>
  );
}

export function ClassicCard({ config, content }: CardProps) {
  const { colorTheme, typography, dimensions } = config;
  
  return (
    <div
      style={{
        width: dimensions.width,
        height: dimensions.height,
        background: colorTheme.background,
        padding: '100px 80px',
        display: 'flex',
        flexDirection: 'column',
        fontFamily: typography.bodyFont,
        fontSize: typography.fontSize,
        lineHeight: typography.lineHeight,
        color: colorTheme.text,
        border: `3px solid ${colorTheme.primary}`,
        position: 'relative'
      }}
    >
      {/* Corner Decorations */}
      <div
        style={{
          position: 'absolute',
          top: '20px',
          left: '20px',
          width: '60px',
          height: '60px',
          border: `2px solid ${colorTheme.primary}`,
          borderRight: 'none',
          borderBottom: 'none'
        }}
      />
      <div
        style={{
          position: 'absolute',
          bottom: '20px',
          right: '20px',
          width: '60px',
          height: '60px',
          border: `2px solid ${colorTheme.primary}`,
          borderLeft: 'none',
          borderTop: 'none'
        }}
      />
      
      {/* Title */}
      {content.title && (
        <h1
          style={{
            fontFamily: typography.headingFont,
            fontSize: typography.fontSize * 2.2,
            lineHeight: 1.3,
            color: colorTheme.primary,
            marginBottom: '30px',
            textAlign: 'center',
            fontWeight: 600,
            letterSpacing: '0.02em'
          }}
        >
          {content.title}
        </h1>
      )}
      
      {/* Divider */}
      <div
        style={{
          width: '200px',
          height: '2px',
          background: colorTheme.accent,
          margin: '0 auto 40px',
          opacity: 0.7
        }}
      />
      
      {/* Content */}
      <div
        style={{
          flex: 1,
          textAlign: 'justify',
          fontSize: typography.fontSize,
          lineHeight: typography.lineHeight
        }}
        dangerouslySetInnerHTML={{ __html: content.body }}
      />
    </div>
  );
}

// src/services/card-renderer.ts
import satori from 'satori';
import sharp from 'sharp';
import { readFile } from 'fs/promises';
import { ModernCard, ClassicCard } from '../components/CardComponent.js';
import type { CardConfig, ParsedContent } from '../types/index.js';

export class CardRenderer {
  private static async loadFont(path: string): Promise<ArrayBuffer> {
    const font = await readFile(path);
    return font.buffer;
  }
  
  static async render(config: CardConfig, content: ParsedContent): Promise<Buffer> {
    // Load fonts (you'll need to add font files to your project)
    const [regularFont, boldFont] = await Promise.all([
      this.loadFont('./assets/fonts/Inter-Regular.ttf'),
      this.loadFont('./assets/fonts/Inter-Bold.ttf')
    ]);
    
    const CardComponent = config.style === 'instagram' ? InstagramCard : 
                         config.style === 'modern' ? ModernCard : ClassicCard;
    
    // Generate SVG using Satori
    const svg = await satori(
      CardComponent({ config, content }),
      {
        width: config.dimensions.width,
        height: config.dimensions.height,
        fonts: [
          {
            name: 'Inter',
            data: regularFont,
            weight: 400,
            style: 'normal'
          },
          {
            name: 'Inter',
            data: boldFont,
            weight: 700,
            style: 'normal'
          }
        ]
      }
    );
    
    // Convert SVG to PNG using Sharp
    const png = await sharp(Buffer.from(svg))
      .png({
        quality: 95,
        compressionLevel: 6
      })
      .toBuffer();
    
    return png;
  }
}

// src/routes/card.ts
import { Hono } from 'hono';
import { MarkdownParser } from '../services/markdown-parser.js';
import { TypographyService } from '../services/typography.js';
import { CardRenderer } from '../services/card-renderer.js';
import type { CardConfig } from '../types/index.js';

const card = new Hono();

card.post('/generate', async (c) => {
  try {
    const body = await c.req.json();
    
    // Default configuration
    const config: CardConfig = {
      content: body.content || '',
      style: body.style || 'modern',
      colorTheme: {
        primary: body.colorTheme?.primary || '#2563eb',
        secondary: body.colorTheme?.secondary || '#64748b',
        accent: body.colorTheme?.accent || '#f59e0b',
        background: body.colorTheme?.background || '#ffffff',
        text: body.colorTheme?.text || '#1f2937'
      },
      typography: {
        headingFont: body.typography?.headingFont || 'Inter',
        bodyFont: body.typography?.bodyFont || 'Inter',
        fontSize: body.typography?.fontSize || 16,
        lineHeight: body.typography?.lineHeight || 1.6
      },
      dimensions: {
        width: body.dimensions?.width || 1600,
        height: body.dimensions?.height || 2000
      },
      features: {
        hangingPunctuation: body.features?.hangingPunctuation ?? true,
        widowOrphanControl: body.features?.widowOrphanControl ?? true,
        coloredText: body.features?.coloredText ?? true,
        svgPattern: body.features?.svgPattern || null
      }
    };
    
    // Validate input
    if (!config.content.trim()) {
      return c.json({ error: 'Content is required' }, 400);
    }
    
    // Parse markdown content
    const parsedContent = MarkdownParser.parse(config.content);
    
    // Apply typography enhancements
    if (config.features.hangingPunctuation) {
      parsedContent.body = TypographyService.applyHangingPunctuation(parsedContent.body);
    }
    
    if (config.features.widowOrphanControl) {
      parsedContent.body = TypographyService.controlWidowsOrphans(parsedContent.body);
    }
    
    // Ensure color contrast
    config.colorTheme.text = TypographyService.ensureContrast(
      config.colorTheme.text,
      config.colorTheme.background
    );
    
    // Generate card
    const imageBuffer = await CardRenderer.render(config, parsedContent);
    
    // Return PNG image
    c.header('Content-Type', 'image/png');
    c.header('Content-Length', imageBuffer.length.toString());
    c.header('Cache-Control', 'public, max-age=3600');
    
    return c.body(imageBuffer);
    
  } catch (error) {
    console.error('Card generation error:', error);
    return c.json({ 
      error: 'Failed to generate card',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, 500);
  }
});

// Health check endpoint
card.get('/health', (c) => {
  return c.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

export { card };

// src/server.ts
import { Hono } from 'hono';
import { logger } from 'hono/logger';
import { cors } from 'hono/cors';
import { serve } from '@hono/node-server';
import { card } from './routes/card.js';

const app = new Hono();

// Middleware
app.use('*', logger());
app.use('*', cors({
  origin: ['http://localhost:3000', 'https://yourdomain.com'],
  allowMethods: ['GET', 'POST', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization']
}));

// Routes
app.route('/api/card', card);

// Root endpoint
app.get('/', (c) => {
  return c.json({
    name: 'Professional Card Generator API',
    version: '1.0.0',
    endpoints: {
      'POST /api/card/generate': 'Generate professional card from Markdown',
      'GET /api/card/health': 'Health check'
    }
  });
});

// Error handling
app.onError((err, c) => {
  console.error('Server error:', err);
  return c.json({
    error: 'Internal server error',
    timestamp: new Date().toISOString()
  }, 500);
});

const port = process.env.PORT ? parseInt(process.env.PORT) : 3000;

console.log(`🚀 Professional Card API starting on port ${port}`);

serve({
  fetch: app.fetch,
  port
});

// README.md usage example
/*
POST /api/card/generate

{
  "content": "# Professional Card\n## Subtitle\nThis is ***highlighted text*** with professional typography.\n\n- Clean design\n- Modern approach\n- High quality",
  "style": "modern",
  "colorTheme": {
    "primary": "#2563eb",
    "secondary": "#64748b", 
    "accent": "#f59e0b",
    "background": "#ffffff",
    "text": "#1f2937"
  },
  "typography": {
    "headingFont": "Inter",
    "bodyFont": "Inter", 
    "fontSize": 16,
    "lineHeight": 1.6
  },
  "features": {
    "hangingPunctuation": true,
    "widowOrphanControl": true,
    "coloredText": true,
    "svgPattern": "dots"
  }
}

Response: PNG image (1600x2000px)
*/
